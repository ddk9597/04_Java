/* 변수
프로그램 실행 시 사용할 값이 있다면 그 값은 변수 선언을 통해 먼저 메모리에 기록한다.
이렇게 기록 된 값은 지속적으로 사용 가능하다.

변수를 사용함으로써 얻는 이점은 아래와 같다.
1. 가독성이 좋아짐
2. 재사용성 증가로 인한 코드량 감소 -> 유지보수 용이

데이터 저장 단위
 - 비트 : 2진수 값 하나를 저장할 수 잇느 메모리공간. 
          데이터의 최소 저장 단위
 - 바이트 : 8개의 비트가 모여 하나의 바이트가 구성됨. 
            데이터처리, 문자의 최소 단위

변수의 선언
-> 메모리 공간에 데이터를 저장할 수 있는 공간을 할당하는 것.
[형태] : 자료형 변수명 ;
ex) boolean isTrue = true; 

// ----------------------------------------

자료형의 종류 - 종류별, 메모리순 정렬

1. 논리형
    1) boolean                  1 byte

2. 숫자형
    1) 정수형
        a. byte                 1 byte
        b. short                2 byte
        c. int(정수 기본)       4 byte
        d. long                 8 byte

    2) 실수형
        a. float                4 byte          
        b. double(실수 기본)    8 byte

3. 문자형
    1) char(문자 하나)          2 byte
    2) String : 변수 참조형. 문자를 이어어 쓰게 하는 변수.

// ----------------------------------

자료형의 종류 2 - 저장 범위 낮은순 정렬
(불차바숏인롱플더)
1. boolean      기본 값 : false
2. char         기본 값 : '\u0000'
3. byte         기본 값 : 0
4. short        기본 값 : 0
5. int          기본 값 : 0
6. long         기본 값 : 0L
7. float        기본 값 : 0.0f
8. double       기본 값 : 0.0 || 0.0d

* String : 참조형으로 저장 범위 따로 없음

// --------------------------------

변수 명명 규칙
1. 대소문자가 구분되며 길이 제한 없음
2. "예약어" 사용하면 안된다
3. 숫자로 시작하면 안된다
4. 특수문자는 _ 와 $만 허용됨
5. 첫글자는 소문자로, 카멜표기법

* 예약어 : 자료형과 같이 java 내에서 사용되는 뜻이 있는 단어

// --------------------------------------

값 대입과 리터럴

    값 대입 : 생성한 변수(저장공간)에 값을 대입하는 것
     -> 변수는 한개의 데이터만 보관하며 
        변수 중복 선언 시 마지막에 대입한 값으로 덮어씌워짐

    리터럴 : 변수에 대입되는 값 자체.
     -> 자료형에 따라 바뀔 수 있음.
     
// --------------------------------------

 변수의 초기화

초기화 : 처음으로 값을 저장하는 것.
         지역변수는 반드시 초기화해야 한다.

선언과 동시에 초기화 가능함.

// --------------------------------------

상수 : 한번만 저장(기록) 할 수 있는 메모리.
- 선언과 동시에 초기화 가능.
- 초기화 이후 다른 데이터(값)을 대입할 수 없다.

// --------------------------------------

문자열 : String
""로 표시함
String 객체를 이용해 저장
String 초기화 시 "" 안의 문자열 이외에 다른 자료형 추가 가능하나
결과는 항상 문자열로 표기됨

ex) 
String str5 = "참치 김밥 " + 5 + "줄 주세요" ;
		System.out.println("str5 : " + str5) ; -> 숫자 5 문자열로 표기

// --------------------------------------

 형변환 : 값(Data)의 자료형을 바꾸는 것 (boolean 제외)

형변환이 이루어지는 경우 -> 컴퓨터의 값 처리 원칙이 지켜지지 않은 경우

<컴퓨터의 값 처리 원칙>
    1. 대입, 계산, 계산의 결과 모두 같은 종류의 자료형끼리만 가능하다.

형변환 예시
    1. (int)10      -> (double)10.0
    2. (char)A      -> (int)65
    3. (float)3.14f -> (int)3

// --------------------------------------
    
자동형변환 : 값의 범위가 큰 자료형 과 값의 범위가 작은 자료형의 연산 시
             "컴파일러:가 자동으로 값의 범위가 작은 자료형을 값의 범위가 큰 자료형으로 변환
             * 컴파일러 :Compiler. 소스 코드를 기계어 또는 바이트 코드로 번역하는 프로그램

byte -> short -> int -> long -> float -> double
        char  -> int -> 위와 동일
* boolean 은 제외된다.
* byte, short의 자료형 값의 계산 결과는 무조건 int로 처리한다.

// --------------------------------------

강제형변환 : 값의 범위가 큰 자료형을 값의 범위가 작은 자료형으로 변환.
             강제 형변환 시 데이터 손실이 발생할 수 있음 -> 데이터의 변형, 손실을 감수하고 강제 형변환한다.

[작성법] : (자료형) 변수명 || 값; -> 지정된 자료형으로 변경된다.

/*
// 강제형변환 확인 1 //
    // -> 자료형변환 + 데이터 손실
    
    int num1 = 290;
    byte result1 = (byte) num1; // 강제 형변환
    
    System.out.println("num1 :" + num1); // 290
    System.out.println("result1 :" + result1); // 34
    
    // 강제형변환 확인2 
    // - 실수를 정수로 변환해서 소수점을 없애기
    // (데이터 손실을 활용)
    
    double num2 = 123.123456789;
    int result2 = (int) num2 ; // 강제형변환
    System.out.println("num2 : " + num2 ); // 123.123456789
    System.out.println("result2 : " + result2 ); // 123
    
    /* 난수 + 강제형변환*/
    
    // 난수 : Math.random(); 범위 : 0.0 <= x < 1.0 ;
    
    // 1~ 10 사이 난수
    //int random = (int)(Math.random() * 10 + 1); // (int)강제형변환을 통해 소수점 아래 자리를 모두 제거함. Js Math.floor 기능
    //System.out.println("random :" + random);
    
    
    // 강제형변환 확인 3 
    // -> 의도적으로 강제 형변환. 값의 범위가 작은 것에서 큰 것으로.
    
    System.out.println(123);		 // (int)	123
    System.out.println((double)123); // (double)123.0
    
    // 강제형변환 확인 4
    // + 값 처리 원칙(같은 자료형 연산 시 같은 자료형 결과가 나온다.)
    // 결과가 나올 때에는 값 처리 원칙이 가장 우선된다.
    
    int num3 = 5;
    int num4 = 2;
    
    System.out.println(num3 / num4); 		          // (int)(5/2) == 2
    System.out.println((double)(num3 / num4));        // (double)((int) 5/ (int) 2) == 2.0 
    System.out.println((double)num3 / (double)num4);  // 5.0 / 2.0 == 2.5 ;
    
    /* 강제형변환 + 자동형변환 + 값처리원칙 */
    System.out.println((double)num3 / num4);  // 5.0 / 2.0 == 2.5 ;
    
    // 다음 순서값의 크기가 서로 다른 연산이 일어남.
    
    // * 강제형변환
    // (double)5.0 / (int)2
    
    // * 자동형변환
    // (double)5.0 / (double) 2.0
    
    // * 값 처리 원칙
    // (double)5.0 / (double) 2.0 == (double) 2.5
    
    // 강제형변환 확인 5
    // 문자(char) <-> 유니코드(int)
    
    System.out.println("A의 번호 : " + 'A' ); // A
    System.out.println("A의 번호 : " + (int)'A' ); // 65
    System.out.println("84번 문자 : " + (char)84 ); // T
    System.out.println("83번 문자 : " + (char)83 ); // S
    

// --------------------------------------

// 데이터 오버플로우
//      0000 ~ 9999 까지 표기 가능한 4자리 기계식 카운터에
//      9999인 상태에서 1을 더하면 0000이 되는 것 처럼
//      각 자료형의 허용 범위를 초과하여 비트를 침범하는 것을 오버플로우 라고 한다.
//      ex) 비에고 버그 등 

// --------------------------------------


// --------------------------------------
// --------------------------------------
// --------------------------------------
// --------------------------------------
// --------------------------------------
// --------------------------------------
// --------------------------------------
// --------------------------------------
// --------------------------------------
// --------------------------------------
// --------------------------------------
// --------------------------------------
// --------------------------------------
// --------------------------------------
// --------------------------------------

// 객체지향 언어
    /*
    * 현실 객체       : 속성(값, data)와 기능(동작, 행동)이 다른 것들과 구분되어 식별 가능한 것

    * 객체 지향 언어  : 현실 객체들을 컴퓨터가 알아먹을 수 있게 만든 문법

    * 자바 객체       : 클래스에 정의된 내용대로 new 연산자를 통해 Heap메모리 영역에 생성된 것
    
    * class           : 객체의 특성(속성, 기능)에 대한 정의를 한 것. 추상화, 캡슐화가 반드시 적용되어야 한다
        -> 추상화 효과 : 코드의 유연성 확보. 상속, 다형성
        -> 캡슐화 효과 : 데이터의 직접 접근 제한 막기 위해. 부가기능 : 정보은닉(외부에서 내부 보이지 않음)
            직접 접근 제한 : 객체의 데이터가 쉽게 변경될 가능성 낮춤

    * new 연산자      : 클래스의 정의내린 내용을 저장된 heap 메모리에 대입하는 연산자

    * 추상화          : 큰 거름망. 유연성을 확보하기 위해 속성과 기능에 구체적인 것은 소거하고 공통으로 적용되는 내용을 추출하는 과정

    * 캡슐화          : 추상화를 통해 정리된 특성(속성, 기능)을 하나로 묶고 속성(데이터)의 직접 접근을 방지하는것

    * 캡슐화 원칙     : 객체 속성 직접 접근 차단
    *   1) private    : 
        2) 간접 접근 방법 작성
    
    heap 영역 할당 시 변수 / 요소가 빈칸으로 있을 수 없다.
    -> 기본 값이 대입되어 있음
    * 
    */



